var documenterSearchIndex = {"docs":
[{"location":"SyntaxReference.html#","page":"Syntax Reference","title":"Syntax Reference","text":"","category":"page"},{"location":"SyntaxReference.html#Main-Macro-and-IO-1","page":"Syntax Reference","title":"Main Macro and IO","text":"","category":"section"},{"location":"SyntaxReference.html#","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [AcuteML]\nPages   = [\"AcuteML.jl\"]","category":"page"},{"location":"SyntaxReference.html#AcuteML.@aml-Tuple{Any}","page":"Syntax Reference","title":"AcuteML.@aml","text":"@aml\n\nType Definition\n\nUse @aml macro to define a Julia type, and then the package automatically creates a xml or html associated with the defined type.\n\nDocument Definition\n\nUse \"html\" or \"xml\" to define a HTML or XML document:\n\n@aml mutable struct Doc \"xml\"\n# add fields (elements) here\nend\n\n@aml mutable struct Web \"html\"\n# add fields (elements) here\nend\n\nNodes (Elements) Definition\n\nSpecify the html/xml struct name as a string after the struct name after a space\n\n@aml mutable struct Person \"person\"\n# add fields (elements) here\nend\n\nIf the html/xml name is the same as struct name, you can use \"~\" instead\n\n@aml mutable struct person \"~\"\n# add fields (elements) here\nend\n\nFields Names\n\nSepecify the html/xml field name as a string in front of the field after ,\n\nfield, \"study-field\"\n\nIf the html/xml name is the same as variable name, you can use \"~\" instead\n\nage::UInt, \"~\"\n\nAttributes\n\nIf the value is going to be an attribute put a before its name\n\nid::Int64, a\"~\"\n\nDefault Value\n\nYou can specify the default value for an argument by using = defVal syntax\n\nGPA::Float64 = 4.5, \"~\"\n\nValue Types\n\nYou can use Julia types or defined types for values. see and Supported Value Types  Custom Value Types for more information.\n\nIf you don't specify the type of a variable, it is considered to be string for aml manipulations:\n\nfield, \"study-field\"\n\nHowever, for a high performance code specify String type (field::String, \"study-field\")\n\nFor already @aml defined types, name should be the same as the defined type root name\n\nuniversity::University, \"university\"\n\nTable types are supported through PrettyTables.jl.\n\nValue Checking\n\nYou can define any restriction for values using functions.\n\nTo define any restrictions for the values of one field, define a function that checks a criteria for the field value and returns Bool, and put its name after a , after the field name:\n\nGPA::Float64, \"~\", GPAcheck\n\nTo define any restrictions for multiple values of a struct, define a function that gets all the variables and checks a criteria and returns Bool, and put its name after a , after the struct name:\n\n@aml mutable struct Person \"person\", courseCheck\n# ...\nend\n\nRefer to https://aminya.github.io/AcuteML.jl/dev/valueChecking/ for some of these functions examples.\n\nOptional Fields\n\nIf a field is optional, don't forget to define its type as UN{} (Union with Nothing), and set the default value as nothing.\n\nresidence::UN{String}=nothing, \"residence-stay\" # optional with nothing as default value\n\nfunds::UN{String}, \"financial-funds\"   # optional, but you should pass nothing manually in construction\n\nEmpty Elements (Self-Closing) Definition\n\nUse sc\"name\" to define a self-closing (empty) element (e.g. <rest />)\n\n@aml struct rest sc\"~\"\nend\n\n\n\nExample - Struct Definition\n\nFirst, we define the structs using @aml to store the data in:\n\nusing AcuteML\n\n# Types definition\n\n# Person Type\n@aml mutable struct Person \"person\", courseCheck\n    age::UInt64, \"~\"\n    field, \"study-field\"\n    GPA::Float64 = 4.5, \"~\", GPAcheck\n    courses::Vector{String}, \"taken-courses\"\n    professors::UN{DataFrame} = nothing, \"table\"\n    id::Int64, a\"~\"\nend\n\n@aml mutable struct University \"university\"\n    name, a\"university-name\"\n    people::Vector{Person}, \"person\"\nend\n\n@aml mutable struct Doc \"xml\"\n    university::University, \"~\"\nend\n\n\n# Value Checking Functions\nGPAcheck(x) = x <= 4.5 && x >= 0\n\nfunction courseCheck(age, field, GPA, courses, id)\n\n    if field == \"Mechanical Engineering\"\n        relevant = [\"Artificial Intelligence\", \"Robotics\", \"Machine Design\"]\n    elseif field == \"Computer Engineering\"\n        relevant = [\"Julia\", \"Algorithms\"]\n    else\n        error(\"study field is not known\")\n    end\n\n    return any(in.(courses, Ref(relevant)))\nend\n\n\n\nExample - Constructor\n\nAfter we defined the structs, we can create instances of them by passing our data to the fields:\n\n\nP1 = Person(age=24, field=\"Mechanical Engineering\", courses=[\"Artificial Intelligence\", \"Robotics\"], id = 1)\nP2 = Person(age=18, field=\"Computer Engineering\", GPA=4, courses=[\"Julia\"], id = 2)\n\nU = University(name=\"Julia University\", people=[P1, P2])\n\nD = Doc(university = U)\n\nD.university.people[2].GPA=4.2 # mutability support after Doc creation\n\n\n# An example that doesn't meet the criteria function for GPA because GPA is more than 4.5\nP3 = Person(age=99, field=\"Macro Wizard\", GPA=10, courses=[\"Julia Magic\"], id = 3)\njulia>\nGPA doesn't meet criteria function\n\njulia> pprint(P1) # or print(P1.aml)\n<person id=\"1\">\n  <age>24</age>\n  <study-field>Mechanical Engineering</study-field>\n  <GPA>4.5</GPA>\n  <taken-courses>Artificial Intelligence</taken-courses>\n  <taken-courses>Robotics</taken-courses>\n</person>\n\njulia> pprint(U) # or print(U.aml)\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\njulia> pprint(D) # or print(D.aml)\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\nP3 with Tables.jl type:\n\nProfs1 = DataFrame(course = [\"Artificial Intelligence\", \"Robotics\"], professor = [\"Prof. A\", \"Prof. B\"] )\n\nP3 = Person(age=24, field=\"Mechanical Engineering\", courses = [\"Artificial Intelligence\", \"Robotics\"], professors= Profs1, id = 1)\n\njulia> pprint(P3)\n\n<person id=\"1\">\n<age>24</age>\n<study-field>Mechanical Engineering</study-field>\n<GPA>4.5</GPA>\n<taken-courses>Artificial Intelligence</taken-courses>\n<taken-courses>Robotics</taken-courses>\n<table>\n<tr class=\"header\">\n<th style=\"text-align: right; \">course</th>\n<th style=\"text-align: right; \">professor</th>\n</tr>\n<tr class=\"subheader headerLastRow\">\n<th style=\"text-align: right; \">String</th>\n<th style=\"text-align: right; \">String</th>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Artificial Intelligence</td>\n<td style=\"text-align: right; \">Prof. A</td>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Robotics</td>\n<td style=\"text-align: right; \">Prof. B</td>\n</tr>\n</table>\n</person>\n\n\n\nExample - Extractor\n\nAfter we defined the structs, we can automatically extract and store the data in their fields:\n\nusing AcuteML\n\nxml = parsexml(\"\"\"\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\"\"\")\n\n# extract Doc\nD = Doc(xml) # StructName(xml) like Doc(xml) extracts the data and stores them in proper format\n\n# Now you can access all of the data by calling the fieldnames\n\n# extract University\nU = D.university\n\njulia>U.name\n\"Julia University\"\n\n# extract Person\n\nP1 = U.people[1]\n\njulia>P1.age\n24\n\njulia>P1.field\nMechanical Engineering\n\njulia>P1.GPA\n4.5\n\njulia>P1.courses\n[\"Artificial Intelligence\", \"Robotics\"]\n\njulia>P1.id\n1\n\n\n\n\n\n","category":"macro"},{"location":"SyntaxReference.html#Templating-1","page":"Syntax Reference","title":"Templating","text":"","category":"section"},{"location":"SyntaxReference.html#","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [AcuteML]\nPages   = [\"templating.jl\"]","category":"page"},{"location":"SyntaxReference.html#AcuteML.newTemplate","page":"Syntax Reference","title":"AcuteML.newTemplate","text":"newTemplate(name)\n\nCreate new destination html file as the template\n\nnewTemplate(name, :function)\n\nPrints a function to be used as a template\n\nExamples\n\n# you can create a file and edit the file directly by using\nnewTemplate(\"person\")\n\n## create person function to store out html template\nnewTemplate(\"person\", :function)\n\n\n\n\n\n","category":"function"},{"location":"SyntaxReference.html#AcuteML.render2file","page":"Syntax Reference","title":"AcuteML.render2file","text":"render2file(destination, overwrite, var...)\n\nrender variables passed as an input to the destination file.\n\nYou should put var in the destination file/string so var is evaluated there. Pass the variables as keyword arguments with the same name you used in the html string/file. Variables should be string,\n\nIf you want to statically overwrite the file pass true as the 2nd argument to the function. Useful if you don't want a dynamic website.\n\nExamples\n\n# Add the following html code to the generated html file\n#=\n<person id=$(id)>\n  <age>$(age)</age>\n  <study-field>$(field)</study-field>\n  <GPA>$(GPA)</GPA>\n  <taken-courses>$(courses[1])</taken-courses>\n  <taken-courses>$(courses[2])</taken-courses>\n</person>\n=#\n\n# Specify the template (or its path), and also the variables for rendering\nout =render2file(\"person\", false,\n  id = 1,\n  age = 24,\n  field = \"Mechanical Engineering\",\n  GPA = 4.5,\n  courses = [\"Artificial Intelligence\", \"Robotics\"])\n\n# you pass `true` as the 2nd argument to owerwrite person.html statically.\n\n\n\n\n\n\n","category":"function"},{"location":"SyntaxReference.html#Backend-utilities-1","page":"Syntax Reference","title":"Backend utilities","text":"","category":"section"},{"location":"SyntaxReference.html#","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [AcuteML]\nPages   = [\"xmlutils.jl\", \"types.jl\", \"initializer.jl\", \"creators.jl\", \"extractors.jl\", \"updaters.jl\"]","category":"page"},{"location":"SyntaxReference.html#AcuteML.docOrElmInit","page":"Syntax Reference","title":"AcuteML.docOrElmInit","text":"docOrElmInit(docOrElmType)\n\nFunction to initialize the aml\n\n\n\n\n\n","category":"function"},{"location":"SyntaxReference.html#AcuteML.addelementOne!-Union{Tuple{T}, Tuple{Document,String,T,Type{#s14} where #s14<:AbsDocOrNode}} where T","page":"Syntax Reference","title":"AcuteML.addelementOne!","text":"addelementOne!(node, name, value, argAmlType)\n\nAdd one element to a node/document\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference.html#AcuteML.addelementVect!-Tuple{Document,String,Array{T,1} where T,Type{#s13} where #s13<:AbsDocOrNode}","page":"Syntax Reference","title":"AcuteML.addelementVect!","text":"addelementVect!(node, name, value, argAmlType)\n\nAdd a vector to a node/document ```\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference.html#AcuteML.findallcontent-Union{Tuple{T}, Tuple{Type{Array{T,1}},String,Node,Type{#s20} where #s20<:AbsNormal}} where T<:String","page":"Syntax Reference","title":"AcuteML.findallcontent","text":"findallcontent(type, string, node, argAmlType)\n\nFinds all the elements with the address of string in the node, and converts the elements to Type object.\n\nfindallcontent(UInt8,\"midi-channel\", node, AbsNormal)\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference.html#AcuteML.findalllocal-Tuple{String,Node}","page":"Syntax Reference","title":"AcuteML.findalllocal","text":"findfirstlocal(string, node)\n\nfindalllocal with ignoring namespaces. It considers element.name for returning the elements\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference.html#AcuteML.findfirstcontent-Union{Tuple{T}, Tuple{Type{T},String,Node,Type{#s13} where #s13<:AbsNormal}} where T<:String","page":"Syntax Reference","title":"AcuteML.findfirstcontent","text":"findfirstcontent(element, node, argAmlType)\nfindfirstcontent(type, element,node, argAmlType)\n\nReturns first element content. It also convert to the desired format by passing type. element is given as string.\n\nfindfirstcontent(\"instrument-name\",node, AbsNormal)\nfindfirstcontent(UInt8,\"midi-channel\",node, AbsNormal)\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference.html#AcuteML.findfirstlocal-Tuple{String,Node}","page":"Syntax Reference","title":"AcuteML.findfirstlocal","text":"findfirstlocal(string, node)\n\nfindfirst with ignoring namespaces. It considers element.name for returning the elements\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference.html#AcuteML.updateallcontent!-Union{Tuple{T}, Tuple{Array{T,1},String,Node,Type{#s19} where #s19<:AbsNormal}} where T<:Union{Number, String}","page":"Syntax Reference","title":"AcuteML.updateallcontent!","text":"updateallcontent!(value, string, node, argAmlType)\n\nFinds all the elements with the address of string in the node, and updates the content\n\n\n\n\n\n","category":"method"},{"location":"SyntaxReference.html#AcuteML.updatefirstcontent!-Union{Tuple{T}, Tuple{T,String,Node,Type{#s21} where #s21<:AbsNormal}} where T<:Union{Number, String}","page":"Syntax Reference","title":"AcuteML.updatefirstcontent!","text":"updatefirstcontent(value, string, node, argAmlType)\n\nUpdates first element content. It also converts any type to string. element is given as string.\n\n\n\n\n\n","category":"method"},{"location":"templating.html#Templating-1","page":"Templating","title":"Templating","text":"","category":"section"},{"location":"templating.html#","page":"Templating","title":"Templating","text":"AcuteML also provides a templating engine if you want to use templates instead of creating the types.","category":"page"},{"location":"templating.html#","page":"Templating","title":"Templating","text":"","category":"page"},{"location":"templating.html#Template-Rendering-using-Functions-1","page":"Templating","title":"Template Rendering using Functions","text":"","category":"section"},{"location":"templating.html#","page":"Templating","title":"Templating","text":"This method only uses functions that return string. You can build your desired string and call the function for rendering.","category":"page"},{"location":"templating.html#","page":"Templating","title":"Templating","text":"## create person function to store out html template\nnewTemplate(\"person\", :function)\n\n\nfunction person(;id, age, field, GPA, courses)\n\n  # Build the taken courses section\n  loopOut=\"\"\n  for course in courses\n    loopOut = loopOut * \"\"\" <taken-courses>$(course)</taken-courses>   \"\"\"\n  end\n\n  # Append all the sections and variables together\n  out = \"\"\"\n  <person id=$(id)>\n    <age>$(age)</age>\n    <study-field>$(field)</study-field>\n    <GPA>$(GPA)</GPA>\n    $loopOut\n  </person>\n  \"\"\"\n\n  return out\nend\n\n# Call the function for rendering\nout = person(\n  id = \"1\",\n  age = \"24\",\n  field = \"Mechanical Engineering\",\n  GPA = \"4.5\",\n  courses = [\"Artificial Intelligence\", \"Robotics\"]\n)\n\nprint(out)\n\n# you can also write the output to a file:\nfile = open(filePath, \"r\"); print(file, out); close(file)","category":"page"},{"location":"templating.html#","page":"Templating","title":"Templating","text":"","category":"page"},{"location":"templating.html#Template-Rendering-using-Files-1","page":"Templating","title":"Template Rendering using Files","text":"","category":"section"},{"location":"templating.html#","page":"Templating","title":"Templating","text":"You can render variables into html/xml files. However, you can't have multiline control flow Julia code in this method.","category":"page"},{"location":"templating.html#","page":"Templating","title":"Templating","text":"# only to set path to current file\ncd(@__DIR__)\n\n\n\n# you can create a file and edit the file directly by using\nnewTemplate(\"person\")\n\n# Add the following html code to the generated html file\n#=\n<person id=$(id)>\n  <age>$(age)</age>\n  <study-field>$(field)</study-field>\n  <GPA>$(GPA)</GPA>\n  <taken-courses>$(courses[1])</taken-courses>\n  <taken-courses>$(courses[2])</taken-courses>\n</person>\n=#\n\n# Specify the template (or its path), and also the variables for rendering\nout =render2file(\"person\", false,\n  id = 1,\n  age = 24,\n  field = \"Mechanical Engineering\",\n  GPA = 4.5,\n  courses = [\"Artificial Intelligence\", \"Robotics\"])\n\n# you pass `true` as the 2nd argument to owerwrite person.html statically.","category":"page"},{"location":"customValueTypes.html#Custom-Value-Types-1","page":"Custom Value Types","title":"Custom Value Types","text":"","category":"section"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"In order to make a custom type work with @aml, you need to define two methods for your type:","category":"page"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"","category":"page"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"# String printing\nstring(x::yourType) = some_string_as_your_type_content\n\n# or\n\n# Node creation\naml(x::yourType) = a_Node","category":"page"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"","category":"page"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"# String parsing\nyourType(x::String) = a_type_made_from_a_string\n\n# or\n\n# Node parsing\nyourType(x::Node) = a_type_made_from_a_Node","category":"page"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"","category":"page"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"Date and Time types are supported through string printing and parsing. Tables compatible types are supported through Node creation and parsing. A combination of two options for each method is also possible.","category":"page"},{"location":"customValueTypes.html#Example-String-printing-and-parsing:-1","page":"Custom Value Types","title":"Example - String printing and parsing:","text":"","category":"section"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"# Defining\nDate(2013,7,1)\n\n# Methods Check\nstring(Date(2013,7,1))\nDate(\"2013-7-1\")\n############################\n# Defining\nTime(12,53,40)\n\n# Methods Check\nstring(Time(12,53,40))\nTime(\"12:53:40\")\n############################\n# Defining\nDateTime(2013,5,1,12,53,40)\n\n# Methods Check\n# check\nstring(DateTime(2013,5,1,12,53,40))\nDateTime(\"2013-05-01T12:53:40\")","category":"page"},{"location":"customValueTypes.html#Example-Node-creation-and-parsing:-1","page":"Custom Value Types","title":"Example - Node creation and parsing:","text":"","category":"section"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"You can directly create a Node using AcuteML utilities. See Custom Constructors for more information.","category":"page"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"You can also use a templating features of AcuteML to make a html as a string. For example, write a html_as_string function that returns the html as a string then, use findfirst(\"html/body/HeaderName\",parsehtml(str)) to parse it.","category":"page"},{"location":"customValueTypes.html#","page":"Custom Value Types","title":"Custom Value Types","text":"function aml(x::YourType)\n  str::Stirng = hmtl_as_string(x)\n\n  html = findfirst(\"html/body/HeaderName\",parsehtml(str))\n  unlink!(html)\n  return html\nend\n","category":"page"},{"location":"extraConstructors.html#Extra-Constructors-1","page":"Extra Contructors","title":"Extra Constructors","text":"","category":"section"},{"location":"extraConstructors.html#Constructors-on-top-of-@aml-1","page":"Extra Contructors","title":"Constructors on top of @aml","text":"","category":"section"},{"location":"extraConstructors.html#","page":"Extra Contructors","title":"Extra Contructors","text":"You can add constructors to your @aml defined type. In the function that you define you should return a call to the type with keywords assigned to the values.","category":"page"},{"location":"extraConstructors.html#Example-1","page":"Extra Contructors","title":"Example","text":"","category":"section"},{"location":"extraConstructors.html#","page":"Extra Contructors","title":"Extra Contructors","text":"In the following example we define two custom constructors for our @aml defined struct.","category":"page"},{"location":"extraConstructors.html#","page":"Extra Contructors","title":"Extra Contructors","text":"\n# define a struct using @aml\n@aml struct Pitch \"pitch\"\n    step::String, \"step\"\n    alter::UN{Float16} = nothing, \"alter\"\n    octave::Int8, \"octave\"\nend","category":"page"},{"location":"extraConstructors.html#","page":"Extra Contructors","title":"Extra Contructors","text":"import MusicXML.pitch2xml  # some function from MusicXML.jl\n\n# 1st custom constructor:\nfunction Pitch(; pitch::Int64)\n\n    step, alter, octave = pitch2xml(pitch)\n\n    return Pitch(step = step, alter = alter, octave = octave) # return the main struct constructor with values assigned as keyword arguments\nend","category":"page"},{"location":"extraConstructors.html#","page":"Extra Contructors","title":"Extra Contructors","text":"# 2nd custom constructor:\nfunction Pitch(; step::String)\n\n    if step == \"C\"\n        octave = 0\n    else\n        octave = 10\n    end\n\n    return Pitch(step = step, octave = octave) # return the main struct constructor with values assigned as keyword arguments\nend\n","category":"page"},{"location":"customConstructors.html#Custom-Constructors-AcuteML-Backend-1","page":"Custom Contructors - AcuteML Backend","title":"Custom Constructors - AcuteML Backend","text":"","category":"section"},{"location":"customConstructors.html#Making-a-Type-and-constructor-from-scratch-1","page":"Custom Contructors - AcuteML Backend","title":"Making a Type and constructor from scratch","text":"","category":"section"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"You can use AcuteML utilities to define custom type constructors from scratch or to override @aml defined constructors.","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"Notice that if you don't use @aml, you should include aml::Node as one of your fields.","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"Functions to use for custom html/xml constructor:","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"docOrElmInit: function to initialize the aml\naddelementOne! : to add single elements\naddelementVect! : to add multiple elements (vector)","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"Use these functions, to make a method that calculates the aml inside the function and returns all of the fields.","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"Functions to use for custom html/xml extractor:","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"findfirstcontent : to extract single elements\nfindallcontent : to extract multiple elements (vector)","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"Use these functions, to make a method that gets the aml::Node and calculates and returns all of the fields.","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"Functions to support mutability:","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"updatefirstcontent!: updates first element content. It also converts any type to string. element is given as string.\nupdateallcontent!: finds all the elements with the address of string in the node, and updates the content","category":"page"},{"location":"customConstructors.html#Example:-1","page":"Custom Contructors - AcuteML Backend","title":"Example:","text":"","category":"section"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"In this example we define Identity with custom constructors:","category":"page"},{"location":"customConstructors.html#","page":"Custom Contructors - AcuteML Backend","title":"Custom Contructors - AcuteML Backend","text":"using AcuteML\n\nmutable struct Identity\n    pitch::UN{Pitch}\n    rest::UN{Rest}\n    unpitched::UN{Unpitched}\n    aml::Node\nend\n\nfunction Identity(;pitch = nothing, rest = nothing, unpitched = nothing)\n\n    # This constructor only allows one the fields to exist - similar to choice element in XS\n\n    aml = docOrElmInit(AbsNormal, \"identity\")\n\n    if pitch != nothing\n        addelementOne!(aml, \"pitch\", pitch, AbsNormal)\n    elseif rest != nothing\n        addelementOne!(aml, \"rest\", rest, AbsNormal)\n    elseif unpitched != nothing\n        addelementOne!(aml, \"unpitched\", unpitched, AbsNormal)\n    else\n        error(\"one of the pitch, rest or unpitched should be given\")\n    end\n\n    return Identity(pitch, rest, unpitched, aml)\nend\n\nfunction Identity(;aml)\n\n        pitch = findfirstcontent(Pitch, \"pitch\", aml, AbsNormal)\n        rest = findfirstcontent(Rest, \"rest\", aml, AbsNormal)\n        unpitched = findfirstcontent(Unpitched, \"unpitched\", aml, AbsNormal)\n\n        return Identity(pitch, rest, unpitched, aml)\nend","category":"page"},{"location":"supportedValueTypes.html#Supported-Value-Types-1","page":"Supported Value Types","title":"Supported Value Types","text":"","category":"section"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"You can use Julia types such as","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"String\nNumber\nBool\nDates and Time\nTables.jl compatible types\n...","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"In addition you can use your @aml defined types in another @aml definition.","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"see Custom Value Types for more information about all supported value types and custom value types.","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"","category":"page"},{"location":"supportedValueTypes.html#@aml-defined-types-1","page":"Supported Value Types","title":"@aml defined types","text":"","category":"section"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"For already @aml defined types, name should be the same as the defined type root name","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"university::University, \"university\"","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"","category":"page"},{"location":"supportedValueTypes.html#Tables-1","page":"Supported Value Types","title":"Tables","text":"","category":"section"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"AcuteML uses PrettyTables.jl to crate HTML from Table type data.","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"# Tables\nProfs1 = DataFrame(course = [\"Artificial Intelligence\", \"Robotics\"], professor = [\"Prof. A\", \"Prof. B\"] )\n\nP3 = Person(age=24, field=\"Mechanical Engineering\", courses = [\"Artificial Intelligence\", \"Robotics\"], professors= Profs1, id = 1)\n\npprint(P3)\n#=\n<person id=\"1\">\n<age>24</age>\n<study-field>Mechanical Engineering</study-field>\n<GPA>4.5</GPA>\n<taken-courses>Artificial Intelligence</taken-courses>\n<taken-courses>Robotics</taken-courses>\n<table>\n<tr class=\"header\">\n<th style=\"text-align: right; \">course</th>\n<th style=\"text-align: right; \">professor</th>\n</tr>\n<tr class=\"subheader headerLastRow\">\n<th style=\"text-align: right; \">String</th>\n<th style=\"text-align: right; \">String</th>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Artificial Intelligence</td>\n<td style=\"text-align: right; \">Prof. A</td>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Robotics</td>\n<td style=\"text-align: right; \">Prof. B</td>\n</tr>\n</table>\n</person>\n=#","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"","category":"page"},{"location":"supportedValueTypes.html#Dates-and-Time:-1","page":"Supported Value Types","title":"Dates and Time:","text":"","category":"section"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"Date","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"Is covered under defined types, and it automatically is converted to the correct format","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"# Defining\nDate(2013,7,1)\nDate(\"2013-7-1\")","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"<some-date>YYYY-MM-DD</some-date>\n<some-date>2013-07-01</some-date>","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"Time","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"Is covered under defined types, and it automatically is converted to the correct format","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"# Defining\nTime(12,53,40)\nTime(\"12:53:40\")","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"<some-time>hh:mm:ss</some-time>\n<some-time>12:53:40</some-time>","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"DateTime","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"Is covered under defined types, and it automatically is converted to the correct format","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"# Defining\nDateTime(2013,5,1,12,53,40)\nDateTime(\"2013-05-01T12:53:40\")","category":"page"},{"location":"supportedValueTypes.html#","page":"Supported Value Types","title":"Supported Value Types","text":"<some-datatime>YYYY-MM-DDThh:mm:ss</some-datatime>\n<some-datatime>2013-05-01T12:53:40</some-datatime>","category":"page"},{"location":"valueChecking.html#Value-Checking-1","page":"Value Checking","title":"Value Checking","text":"","category":"section"},{"location":"valueChecking.html#Example-for-Common-Value-Restriction-functions-1","page":"Value Checking","title":"Example for Common Value Restriction functions","text":"","category":"section"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"Restrictions should be given as a function that returns Bool and the function checks for elements.","category":"page"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"For example, for a vector of strings:","category":"page"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"@aml struct Person \"person\"\n   member::Vector{String}, \"member\", memberCheck\nend","category":"page"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"Value limit check:","category":"page"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"memberCheck(x) = any( x>10 || x<5 )  # in a compact form: x-> any(x>10 || x<5)\n# x is all the values as a vector in this case","category":"page"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"Check of the length of the vector:","category":"page"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"memberCheck(x) = 0 < length(x) && length(x) < 10","category":"page"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"User should know if the vector is going to be 0-element, its type should be union with nothing, i.e., UN{}. This is because of the EzXML implementation of findfirst and findall.","category":"page"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"Set of valuse:","category":"page"},{"location":"valueChecking.html#","page":"Value Checking","title":"Value Checking","text":"setOfValues = [2,4,10]\nmemberCheck(x) = in.(x, setOfValues)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = AcuteML","category":"page"},{"location":"index.html#AcuteML-1","page":"Home","title":"AcuteML","text":"","category":"section"},{"location":"index.html#Acute-Markup-Language-1","page":"Home","title":"Acute Markup Language","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"AcuteML is an Acute Markup Language (AML) for Web/XML development in Julia.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"It automatically creates or extracts HTML/XML files from Julia types!\nIt also has a general templating engine, which can be used for any type of documents.","category":"page"},{"location":"index.html#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Add the package","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AcuteML\")","category":"page"},{"location":"index.html#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Use the package:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"using AcuteML","category":"page"},{"location":"index.html#Main-macro-and-I/O-1","page":"Home","title":"Main macro and I/O","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"@aml","category":"page"},{"location":"index.html#AcuteML.@aml","page":"Home","title":"AcuteML.@aml","text":"@aml\n\nType Definition\n\nUse @aml macro to define a Julia type, and then the package automatically creates a xml or html associated with the defined type.\n\nDocument Definition\n\nUse \"html\" or \"xml\" to define a HTML or XML document:\n\n@aml mutable struct Doc \"xml\"\n# add fields (elements) here\nend\n\n@aml mutable struct Web \"html\"\n# add fields (elements) here\nend\n\nNodes (Elements) Definition\n\nSpecify the html/xml struct name as a string after the struct name after a space\n\n@aml mutable struct Person \"person\"\n# add fields (elements) here\nend\n\nIf the html/xml name is the same as struct name, you can use \"~\" instead\n\n@aml mutable struct person \"~\"\n# add fields (elements) here\nend\n\nFields Names\n\nSepecify the html/xml field name as a string in front of the field after ,\n\nfield, \"study-field\"\n\nIf the html/xml name is the same as variable name, you can use \"~\" instead\n\nage::UInt, \"~\"\n\nAttributes\n\nIf the value is going to be an attribute put a before its name\n\nid::Int64, a\"~\"\n\nDefault Value\n\nYou can specify the default value for an argument by using = defVal syntax\n\nGPA::Float64 = 4.5, \"~\"\n\nValue Types\n\nYou can use Julia types or defined types for values. see and Supported Value Types  Custom Value Types for more information.\n\nIf you don't specify the type of a variable, it is considered to be string for aml manipulations:\n\nfield, \"study-field\"\n\nHowever, for a high performance code specify String type (field::String, \"study-field\")\n\nFor already @aml defined types, name should be the same as the defined type root name\n\nuniversity::University, \"university\"\n\nTable types are supported through PrettyTables.jl.\n\nValue Checking\n\nYou can define any restriction for values using functions.\n\nTo define any restrictions for the values of one field, define a function that checks a criteria for the field value and returns Bool, and put its name after a , after the field name:\n\nGPA::Float64, \"~\", GPAcheck\n\nTo define any restrictions for multiple values of a struct, define a function that gets all the variables and checks a criteria and returns Bool, and put its name after a , after the struct name:\n\n@aml mutable struct Person \"person\", courseCheck\n# ...\nend\n\nRefer to https://aminya.github.io/AcuteML.jl/dev/valueChecking/ for some of these functions examples.\n\nOptional Fields\n\nIf a field is optional, don't forget to define its type as UN{} (Union with Nothing), and set the default value as nothing.\n\nresidence::UN{String}=nothing, \"residence-stay\" # optional with nothing as default value\n\nfunds::UN{String}, \"financial-funds\"   # optional, but you should pass nothing manually in construction\n\nEmpty Elements (Self-Closing) Definition\n\nUse sc\"name\" to define a self-closing (empty) element (e.g. <rest />)\n\n@aml struct rest sc\"~\"\nend\n\n\n\nExample - Struct Definition\n\nFirst, we define the structs using @aml to store the data in:\n\nusing AcuteML\n\n# Types definition\n\n# Person Type\n@aml mutable struct Person \"person\", courseCheck\n    age::UInt64, \"~\"\n    field, \"study-field\"\n    GPA::Float64 = 4.5, \"~\", GPAcheck\n    courses::Vector{String}, \"taken-courses\"\n    professors::UN{DataFrame} = nothing, \"table\"\n    id::Int64, a\"~\"\nend\n\n@aml mutable struct University \"university\"\n    name, a\"university-name\"\n    people::Vector{Person}, \"person\"\nend\n\n@aml mutable struct Doc \"xml\"\n    university::University, \"~\"\nend\n\n\n# Value Checking Functions\nGPAcheck(x) = x <= 4.5 && x >= 0\n\nfunction courseCheck(age, field, GPA, courses, id)\n\n    if field == \"Mechanical Engineering\"\n        relevant = [\"Artificial Intelligence\", \"Robotics\", \"Machine Design\"]\n    elseif field == \"Computer Engineering\"\n        relevant = [\"Julia\", \"Algorithms\"]\n    else\n        error(\"study field is not known\")\n    end\n\n    return any(in.(courses, Ref(relevant)))\nend\n\n\n\nExample - Constructor\n\nAfter we defined the structs, we can create instances of them by passing our data to the fields:\n\n\nP1 = Person(age=24, field=\"Mechanical Engineering\", courses=[\"Artificial Intelligence\", \"Robotics\"], id = 1)\nP2 = Person(age=18, field=\"Computer Engineering\", GPA=4, courses=[\"Julia\"], id = 2)\n\nU = University(name=\"Julia University\", people=[P1, P2])\n\nD = Doc(university = U)\n\nD.university.people[2].GPA=4.2 # mutability support after Doc creation\n\n\n# An example that doesn't meet the criteria function for GPA because GPA is more than 4.5\nP3 = Person(age=99, field=\"Macro Wizard\", GPA=10, courses=[\"Julia Magic\"], id = 3)\njulia>\nGPA doesn't meet criteria function\n\njulia> pprint(P1) # or print(P1.aml)\n<person id=\"1\">\n  <age>24</age>\n  <study-field>Mechanical Engineering</study-field>\n  <GPA>4.5</GPA>\n  <taken-courses>Artificial Intelligence</taken-courses>\n  <taken-courses>Robotics</taken-courses>\n</person>\n\njulia> pprint(U) # or print(U.aml)\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\njulia> pprint(D) # or print(D.aml)\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\nP3 with Tables.jl type:\n\nProfs1 = DataFrame(course = [\"Artificial Intelligence\", \"Robotics\"], professor = [\"Prof. A\", \"Prof. B\"] )\n\nP3 = Person(age=24, field=\"Mechanical Engineering\", courses = [\"Artificial Intelligence\", \"Robotics\"], professors= Profs1, id = 1)\n\njulia> pprint(P3)\n\n<person id=\"1\">\n<age>24</age>\n<study-field>Mechanical Engineering</study-field>\n<GPA>4.5</GPA>\n<taken-courses>Artificial Intelligence</taken-courses>\n<taken-courses>Robotics</taken-courses>\n<table>\n<tr class=\"header\">\n<th style=\"text-align: right; \">course</th>\n<th style=\"text-align: right; \">professor</th>\n</tr>\n<tr class=\"subheader headerLastRow\">\n<th style=\"text-align: right; \">String</th>\n<th style=\"text-align: right; \">String</th>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Artificial Intelligence</td>\n<td style=\"text-align: right; \">Prof. A</td>\n</tr>\n<tr>\n<td style=\"text-align: right; \">Robotics</td>\n<td style=\"text-align: right; \">Prof. B</td>\n</tr>\n</table>\n</person>\n\n\n\nExample - Extractor\n\nAfter we defined the structs, we can automatically extract and store the data in their fields:\n\nusing AcuteML\n\nxml = parsexml(\"\"\"\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<university university-name=\"Julia University\">\n  <person id=\"1\">\n    <age>24</age>\n    <study-field>Mechanical Engineering</study-field>\n    <GPA>4.5</GPA>\n    <taken-courses>Artificial Intelligence</taken-courses>\n    <taken-courses>Robotics</taken-courses>\n  </person>\n  <person id=\"2\">\n    <age>18</age>\n    <study-field>Computer Engineering</study-field>\n    <GPA>4.2</GPA>\n    <taken-courses>Julia</taken-courses>\n  </person>\n</university>\n\"\"\")\n\n# extract Doc\nD = Doc(xml) # StructName(xml) like Doc(xml) extracts the data and stores them in proper format\n\n# Now you can access all of the data by calling the fieldnames\n\n# extract University\nU = D.university\n\njulia>U.name\n\"Julia University\"\n\n# extract Person\n\nP1 = U.people[1]\n\njulia>P1.age\n24\n\njulia>P1.field\nMechanical Engineering\n\njulia>P1.GPA\n4.5\n\njulia>P1.courses\n[\"Artificial Intelligence\", \"Robotics\"]\n\njulia>P1.id\n1\n\n\n\n\n\n","category":"macro"}]
}
